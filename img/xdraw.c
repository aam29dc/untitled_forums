#include "xdraw.h"<br>int drawLine(const int x1, const int y1, const int x2, const int y2) {<br>&emsp;COORD coord = { 0 };<br>&emsp;double m = 0;<br>&emsp;int i, j, x, y = 0;<br>&emsp;if (x1 == x2) {<br>&emsp;&emsp;y = xabsol(y1 - y2) + 1;<br>&emsp;&emsp;coord.X = (short)x1;<br>&emsp;&emsp;coord.Y = (y1 < y2) ? (short)y1 : (short)y2;<br>&emsp;&emsp;for (i = 0; i < y; i++) {<br>&emsp;&emsp;&emsp;printPixel(coord, PIXEL);<br>&emsp;&emsp;&emsp;coord.Y++;<br>&emsp;&emsp;}<br>&emsp;&emsp;return 0;<br>&emsp;}<br>&emsp;m = (double)(y1 - y2) / (x1 - x2);<br>&emsp;i = x1 < x2 ? x1 : x2;<br>&emsp;x = x1 < x2 ? x2 : x1;<br>&emsp;for (; i < x; i++) {<br>&emsp;&emsp;if (m == 0) y = 1;<br>&emsp;&emsp;else if (m == (int)m) y = (int)xabsolf(m);<br>&emsp;&emsp;else y = (int)xabsolf(m) + 1;<br>&emsp;&emsp;coord.X = (short)i;<br>&emsp;&emsp;for (j = 0; j < y; j++) {<br>&emsp;&emsp;&emsp;if (m >= 0) coord.Y = (short)(xroundf(m * (i - x1) + y1) + j);<br>&emsp;&emsp;&emsp;else coord.Y = (short)(xroundf(m * (i - x1) + y1) - j);<br>&emsp;&emsp;&emsp;printPixel(coord, PIXEL);<br>&emsp;&emsp;}<br>&emsp;}<br>&emsp;return 0;<br>}<br>int fillTriangle(int x1, int y1, int x2, int y2, int x3, int y3) {<br>&emsp;int i, j, dy = 0;<br>&emsp;double m = 0;<br>&emsp;if ((x1 == x2 && y1 == y2) || (x1 == x3 && y1 == y3) || (x2 == x3 && y2 == y3))	return ERR_PARA;<br>&emsp;if (x2 < x1) { xswap(&x1, &x2, sizeof(int));xswap(&y1, &y2, sizeof(int)); }<br>&emsp;if (x3 < x1) { xswap(&x1, &x3, sizeof(int));xswap(&y1, &y3, sizeof(int)); }<br>&emsp;if (x3 < x2) { xswap(&x2, &x3, sizeof(int));xswap(&y2, &y3, sizeof(int)); }<br>&emsp;if (x2 == x3) {<br>&emsp;&emsp;if (y3 < y2) xswap(&y3, &y2, sizeof(int));<br>&emsp;&emsp;for (i = y2; i < (y3 + 1); i++) {<br>&emsp;&emsp;&emsp;drawLine(x1, y1, x2, i);<br>&emsp;&emsp;}<br>&emsp;}<br>&emsp;else {<br>&emsp;&emsp;m = (double)(y2 - y3) / (x2 - x3);<br>&emsp;&emsp;if (m == 0) dy = 1;<br>&emsp;&emsp;else if (m == (int)m) dy = (int)xabsolf(m);<br>&emsp;&emsp;else dy = (int)xabsolf(m) + 1;<br>&emsp;&emsp;printf("%f %d %d", m, (int)m, dy);<br>&emsp;&emsp;for (i = x2; i <= x3; i++) {<br>&emsp;&emsp;&emsp;for (j = 0; j < dy; j++) {<br>&emsp;&emsp;&emsp;&emsp;if (m >= 0)<br>&emsp;&emsp;&emsp;&emsp;&emsp;drawLine(x1, y1, i, xroundf(y2 + m * (i - x2)) + j);<br>&emsp;&emsp;&emsp;&emsp;else<br>&emsp;&emsp;&emsp;&emsp;&emsp;drawLine(x1, y1, i, xroundf(y2 + m * (i - x2)) - j);<br>&emsp;&emsp;&emsp;}<br>&emsp;&emsp;}<br>&emsp;}<br>&emsp;return 0;<br>}<br>int matrix_drawEdges(const MATRIX* const A, const size_t* const adj) {<br>&emsp;size_t i,j = 0;<br>&emsp;if (adj == NULL || A == NULL) return ERR_NUL;<br>&emsp;for (j = 0; j < A->cols; j++) {<br>&emsp;&emsp;for (i = j; i < A->cols; i++) {<br>&emsp;&emsp;&emsp;if (adj[i + (j * A->cols)] == 1) {<br>&emsp;&emsp;&emsp;&emsp;if (drawLine(xroundf(A->m[i]), xroundf(A->m[i + A->cols]), xroundf(A->m[j]), xroundf(A->m[j + A->cols]))) return ERR_FUNC;<br>&emsp;&emsp;&emsp;}<br>&emsp;&emsp;}<br>&emsp;}<br>&emsp;return 0;<br>}<br>